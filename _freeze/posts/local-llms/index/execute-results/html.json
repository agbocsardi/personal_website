{
  "hash": "8a41153c6b810ca3165dfbcde09553d6",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"How I Run Local LLMs\"\ndescription: \"In this article I show you how I set up local LLMs in VSCode. We'll use them for code completion and chat, right inside your code editor.\"\n\ndate: \"2024.12.06\"\ndate-modified: \"2024.12.06\"\n\ncategories:\n  - notetaking\n  - howto\n\nformat:\n  html:\n    code-overflow: wrap\n\naliases: \n  - /local-llms.html\n---\n\n---\n\nUPDATE: I gave a presentation on this, with some updated tooling! Check it out [here](/posts/presentation-local-llms/index.qmd)!\n---\n\n\n\n\n## Why bother setting this up\n\nFirst and foremost, sometimes GitHub Copilot is just not available for your editor. This is how I arrived here, since I started using [Positron](https://github.com/posit-dev/positron) as my IDE for all things Python and R, and at the time of writing, you cannot use Copilot in it. Chat I could live without, but the missing the AI code-completion really hurt.\n\nAnother significant benefit is the ability to maintain complete control over your work's privacy - not everything needs or should be uploaded to an API. By running local models you can be sure that no sensitive information leaks out, which comes in handy if you're working with sensitive data or documents. \n\n\nWe have two main objectives to get this up and running. First, you'll need to host and run the models themselves, which involves setting up the necessary infrastructure to get them up and running. Once that's taken care of, step two is finding a way of interacting with the LLMs in a way that feels intuitive and natural - whether that's using them for code completion or engaging in conversation.\n\n\n## Pre-requisites\nBefore diving into setting up your local LLMs, let's make sure you have the necessary pre-requisites met. First and foremost, you'll need to have VSCode installed on your machine - this will be the hub where you interact with your LLMs.\n\nIn addition to having a capable code editor, it's also essential to be not be terrified of working in the terminal. We're not going to do anything crazy, you don't have to be a unix-wizard, but we're gonna rely on some terminal commands during the setup.\n\nFinally, your machine will need to meet certain hardware requirements. While my own 14-inch M1 Pro MacBook Pro with 16GB of RAM has been more than sufficient for running smaller models (up to 7B or so), it's worth noting that the amount of RAM on your machine directly impacts how large a model you can run without issues. \n\nIf your machine is equipped with a stronger GPU, you'll also see a noticeable boost in inference speeds - but if you only have CPU, things will still work, just at a slightly slower pace.\n\n\n## Ollama\nNow that we've covered the basics, let's dive into using Ollama to host and manage our local LLMs.Ollama is an app designed specifically for running and managing local LLMs, and it's incredibly easy to get started with. \n\nFirst, head over to the [Ollama website](https://ollama.com/) and explore the vast library of models available - you'll find a wide range of sizes and types to suit your needs. Don't worry if this feels overwhelming, we're going to tackle model selection in the next section.\n\nTo begin using Ollama, simply go through the install steps on [their website](https://ollama.com/). Once installed, make sure it's running in the background - this will be our central engine for running and managing our local LLMs.\n\n\n### Model choice\nNow that you have installed Ollama, let's dive into choosing a suitable model for your needs. This is where things get a bit more subjective, as the ideal model will depend on your personal preferences and use cases. \n\nWhen selecting a model, you'll need to find one that balances two key factors: size (in terms of parameters) and performance (inference speed). On one hand, a larger model will generally be more capable and useful, but it may also consume more resources and take longer to reply. Conversely, a smaller model, while faster to reply, but might struggle with more complex tasks.\n\nYou'll likely want to have different models for various purposes, in our case, code completion, chat, and embeddings. Let's take a closer look at each of these categories:\n\n#### Code Completion\nFor code completion, my personal preference is speed over depth. I just want to avoid retyping lines for multiple calls, and any decent model should be able to handle this efficiently.\n\nI've found that the [`qwen2.5-coder:1.5b`](https://ollama.com/library/qwen2.5-coder:1.5b) model from Ollama's library is pretty good for code completion. It has other varieties with larger models (3B) that are still reasonable-sized for completion on a stronger consumer machine, but for the basics, the 1.5B flavor is plenty.\n\n#### Chat\nWhen it comes to chat, things get more nuanced. You'll need to like the \"vibe\" of the model and find one that gives you the types of answers you're looking for. \n\nFor small models, I recommend checking out [`phi3.5:3.8b`](https://ollama.com/library/phi3.5:3.8b), which is Microsoft's take on Small Language Models. They've curated the training data carefully, resulting in a pretty cool chat experience for such a lightweight model.\n\nIf you prefer larger models, consider using [`llama3.1:8b`](https://ollama.com/library/llama3.1:8b), which is Meta's top-of-the-line open source Llama model, the 8B parameter version. This should use around 6-7GBs of RAM while generating, so keep this in mind when running multiple models together. This model is the one I use for most of my work.\n\n#### Embeddings\nFinally, for embeddings, I simply used the one that Ollama recommends: `nomic-embed-text`. It worked reasonably well for RAG-style tasks, so I didn't need to experiment further than this.\n\n\n**For the remainder of the tutorial, I'll assume that you are using `qwen2.5-coder:1.5b`, `phi3.5:3.8b` and `nomic-embed-text`. ** \n\nCode to download them:\n```sh\nollama pull qwen2.5-coder:1.5B\nollama pull phi3.5:3.8b\nollama pull nomic-embed-text\n```\n\n### Ollama cheatsheet\nSome useful commands to know:\n\n- list all available models: `ollama list`\n- show currently running models: `ollama ps`\n- remove model: `ollama rm {model name without brackets}`\n- run model in command line: `ollama run {model name without brackets}`\n\n\n## Continue.dev\nNow that you have set up your engine for running the models locally, I'd like to introduce you to another powerful tool: Continue.dev.\n\nContinue.dev is an open-source AI code assistant designed specifically for VSCode (and JetBrains, too!). It offers a range of features to help with coding tasks. To get started, refer to the Continue.dev documentation and follow the installation instructions for VSCode. Note that during setup, you may encounter requests to configure API connections; since we're running our LLMs locally, these can be skipped. \n\nJust keep in mind that when setting up Continue.dev, you might encounter some API setup requests, but we can skip those since we're running our LLMs locally.\n\n\n### Setup of Continue\nEverything happens in the `config.json` file that you can open by clicking the little cog in the corner of the continue pane.\n\nNow, if you're unfamiliar with JSON, this might be scary, but it's not as bad as it looks. Let's go through it together:\n\nYou specify `model` objects here, that look like this:\n```json\n    {\n      \"title\": \"Big Llama = Whatever name you want to give your model \",\n      \"model\": \"llama3.1:8b = Name of the model, exactly as seen in 'ollama list'. You have to use the colons with the weight too!\",\n      \"provider\": \"ollama = This tells Continue that it should look for a local model.\"\n    }\n```\n\nYou need to specify which model you want to use like this these for the chat model (under `models` at the top) and for the code complete model (under `tabAutocompleteModel`). The only exception is the embedding model, that one doesn't have a \"title\" field.\n\nAn example of a full `config.json` using the models I mentioned above can be found below, feel free to copy it into your own! It's the full config file, just with the models adjusted, all the other settings are defaults.\n\n::: {#8f496ab9 .cell execution_count=1}\n``` {.python .cell-code code-fold=\"true\" code-summary=\"example config.json\"}\n{\n  \"models\": [\n  \n    {\n      \"title\": \"Phi 3.5\",\n      \"model\": \"phi3.5:3.8b\",\n      \"provider\": \"ollama\"\n    },\n    // i included a commented other model, so you can see how you can have multiple chat models. you can even switch between them!\n    // {\n    // \"title\": \"Big Llama\",\n    // \"model\": \"llama3.1:8b\",\n    // \"provider\": \"ollama\"\n    // },\n  ],\n\n  \"tabAutocompleteModel\": \n  {\n    \"title\": \"qwen2.5-coder:1.5b\",\n    \"provider\": \"ollama\",\n    \"model\": \"qwen2.5-coder:1.5b\"\n  }\n  ,\n  \"tabAutocompleteOptions\": {\n    \"multilineCompletions\": auto,\n  },\n\n  \"embeddingsProvider\": {\n    \"provider\": \"ollama\",\n    \"model\": \"nomic-embed-text\"\n  }\n  ,\n\n  \"customCommands\": [\n    {\n      \"name\": \"test\",\n      \"prompt\": \"{{{ input }}}\\n\\nWrite a comprehensive set of unit tests for the selected code. It should setup, run tests that check for correctness including important edge cases, and teardown. Ensure that the tests are complete and sophisticated. Give the tests just as chat output, don't edit any file.\",\n      \"description\": \"Write unit tests for highlighted code\"\n    }\n  ],\n  \"contextProviders\": [\n    {\n      \"name\": \"code\",\n      \"params\": {}\n    },\n    {\n      \"name\": \"docs\",\n      \"params\": {}\n    },\n    {\n      \"name\": \"diff\",\n      \"params\": {}\n    },\n    {\n      \"name\": \"terminal\",\n      \"params\": {}\n    },\n    {\n      \"name\": \"problems\",\n      \"params\": {}\n    },\n    {\n      \"name\": \"folder\",\n      \"params\": {}\n    },\n    {\n      \"name\": \"codebase\",\n      \"params\": {}\n    }\n  ],\n  \"slashCommands\": [\n    {\n      \"name\": \"share\",\n      \"description\": \"Export the current chat session to markdown\"\n    },\n    {\n      \"name\": \"cmd\",\n      \"description\": \"Generate a shell command\"\n    },\n    {\n      \"name\": \"commit\",\n      \"description\": \"Generate a git commit message\"\n    }\n  ]\n}\n```\n:::\n\n\n### Using Continue\n\nI think the [Continue Docs](https://docs.continue.dev/getting-started/overview) do a great job of introducing themselves, so I won't try to do one better. Most things they do is quite close to Github Copilot, so if you're familiar with that, you'll feel right at home.\n\n<iframe src=\"https://docs.continue.dev/getting-started/overview\" title=\"Continue.dev Docs - Overview\" width = 100% height =600px></iframe>\n\n\n\n\n\n## Summary\nI hope this tutorial gave you can help expand your horizons in what's possible with locally hosted LLMs! \n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}